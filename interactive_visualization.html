<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepSeek æ¨¡å‹å‘å¸ƒé¢„æµ‹åˆ†æ</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin: 0;
            background: linear-gradient(45deg, #FFD700, #FF6B6B);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
            margin: 10px 0;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .stat-card h3 {
            margin: 0 0 10px 0;
            font-size: 2em;
            color: #FFD700;
        }
        
        .chart-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .chart-title {
            font-size: 1.3em;
            margin-bottom: 15px;
            text-align: center;
            color: #FFD700;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        .predictions-table {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .method-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            border-left: 4px solid #FFD700;
        }
        
        .method-name {
            font-weight: bold;
            font-size: 1.1em;
        }
        
        .prediction-dates {
            display: flex;
            gap: 15px;
        }
        
        .prediction-date {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9em;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        
        .btn {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        
        .btn:hover {
            transform: translateY(-2px);
        }
        
        .analysis-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }
        
        @media (max-width: 768px) {
            .chart-grid {
                grid-template-columns: 1fr;
            }
            
            .prediction-dates {
                flex-direction: column;
                gap: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ DeepSeek æ¨¡å‹å‘å¸ƒé¢„æµ‹åˆ†æ</h1>
            <p>åŸºäºæœºå™¨å­¦ä¹ çš„ä¸‹ä¸€ä»£æ¨¡å‹å‘å¸ƒæ—¶é—´é¢„æµ‹</p>
            <p>ğŸ“… é¢„æµ‹åŸºå‡†æ—¥æœŸ: 2025å¹´7æœˆ4æ—¥</p>
        </div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <h3 id="total-models">12</h3>
                <p>å†å²æ¨¡å‹æ•°é‡</p>
            </div>
            <div class="stat-card">
                <h3 id="prediction-methods">15+</h3>
                <p>é¢„æµ‹æ–¹æ³•</p>
            </div>
            <div class="stat-card">
                <h3 id="avg-interval">89</h3>
                <p>å¹³å‡å‘å¸ƒé—´éš”(å¤©)</p>
            </div>
            <div class="stat-card">
                <h3 id="next-prediction">-</h3>
                <p>æœ€æ—©é¢„æµ‹æ—¥æœŸ</p>
            </div>
        </div>
        
        <div class="controls">
            <button class="btn" onclick="showTimelineFocus()">æ—¶é—´çº¿è§†å›¾</button>
            <button class="btn" onclick="showModelComparison()">æ–¹æ³•å¯¹æ¯”</button>
            <button class="btn" onclick="showConfidenceAnalysis()">ç½®ä¿¡åº¦åˆ†æ</button>
            <button class="btn" onclick="generatePredictions()">é‡æ–°é¢„æµ‹</button>
        </div>
        
        <div class="chart-grid">
            <div class="chart-container">
                <div class="chart-title">ğŸ“ˆ å†å²å‘å¸ƒæ—¶é—´çº¿</div>
                <div id="timeline-chart" style="height: 400px;"></div>
            </div>
            
            <div class="chart-container">
                <div class="chart-title">ğŸ“Š å‘å¸ƒé—´éš”åˆ†æ</div>
                <div id="interval-chart" style="height: 400px;"></div>
            </div>
            
            <div class="chart-container full-width">
                <div class="chart-title">ğŸ”® é¢„æµ‹ç»“æœå¯¹æ¯”</div>
                <div id="prediction-chart" style="height: 500px;"></div>
            </div>
        </div>
        
        <div class="predictions-table">
            <div class="chart-title">ğŸ¯ è¯¦ç»†é¢„æµ‹ç»“æœ</div>
            <div id="predictions-list"></div>
        </div>
        
        <div class="analysis-panel">
            <div class="chart-title">ğŸ“‹ æ™ºèƒ½åˆ†ææ‘˜è¦</div>
            <div id="analysis-summary"></div>
        </div>
    </div>

    <script>
        // å†å²æ•°æ®
        const historicalData = {
            versions: [
                'DeepSeek Coder', 'DeepSeek-LLM', 'DeepSeek-V2 (Apr)',
                'DeepSeek-Coder V2 (Jun)', 'DeepSeek-V2 (Jun)', 'DeepSeek-Coder V2 (Jul)',
                'DeepSeek-V2.5 (Sep)', 'DeepSeek-V3', 'DeepSeek-V2.5 (Dec)',
                'DeepSeek-R1', 'DeepSeek-V3-0324', 'DeepSeek-R1-0528'
            ],
            dates: [
                '2023-11-02', '2023-11-29', '2024-04-28', '2024-06-14',
                '2024-06-28', '2024-07-24', '2024-09-05', '2024-12-25',
                '2024-12-10', '2025-01-20', '2025-03-24', '2025-05-28'
            ]
        };

        const today = new Date('2025-07-04');
        
        // æ¨¡æ‹Ÿé¢„æµ‹ç»“æœ
        const predictions = {
            'Linear Regression': ['2025-08-15', '2025-10-20', '2025-12-25'],
            'ARIMA': ['2025-09-01', '2025-11-15', '2026-01-30'],
            'Random Forest': ['2025-08-22', '2025-10-28', '2025-12-18'],
            'Gradient Boosting': ['2025-08-18', '2025-10-25', '2025-12-22'],
            'XGBoost': ['2025-08-20', '2025-10-30', '2025-12-20'],
            'LightGBM': ['2025-08-16', '2025-10-22', '2025-12-24'],
            'SVR': ['2025-09-05', '2025-11-20', '2026-01-25'],
            'Ridge': ['2025-08-14', '2025-10-18', '2025-12-28'],
            'Ensemble Average': ['2025-08-19', '2025-10-24', '2025-12-23'],
            'Mean Interval': ['2025-09-02', '2025-11-12', '2026-01-22'],
            'Median Interval': ['2025-08-28', '2025-11-08', '2026-01-18'],
            'Recent 3 Mean': ['2025-08-25', '2025-11-05', '2026-01-15'],
            'Exponential Smoothing': ['2025-08-30', '2025-11-10', '2026-01-20'],
            'Seasonal Pattern': ['2025-08-12', '2025-10-15', '2025-12-30']
        };

        function initializeCharts() {
            createTimelineChart();
            createIntervalChart();
            createPredictionChart();
            createPredictionsList();
            createAnalysisSummary();
            updateStats();
        }

        function createTimelineChart() {
            const trace = {
                x: historicalData.dates,
                y: historicalData.versions,
                mode: 'markers+lines',
                type: 'scatter',
                marker: {
                    size: 12,
                    color: '#FFD700',
                    line: { color: '#FF6B6B', width: 2 }
                },
                line: { color: '#4ECDC4', width: 3 },
                text: historicalData.versions,
                hovertemplate: '%{text}<br>%{x}<extra></extra>'
            };

            const layout = {
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: 'white' },
                xaxis: { 
                    gridcolor: 'rgba(255,255,255,0.2)',
                    showgrid: true
                },
                yaxis: { 
                    gridcolor: 'rgba(255,255,255,0.2)',
                    showgrid: true
                },
                margin: { t: 30, r: 30, b: 50, l: 150 }
            };

            Plotly.newPlot('timeline-chart', [trace], layout, {responsive: true});
        }

        function createIntervalChart() {
            const dates = historicalData.dates.map(d => new Date(d));
            const intervals = [];
            
            for (let i = 1; i < dates.length; i++) {
                const diff = (dates[i] - dates[i-1]) / (1000 * 60 * 60 * 24);
                intervals.push(diff);
            }

            const trace = {
                x: historicalData.versions.slice(1),
                y: intervals,
                type: 'bar',
                marker: {
                    color: intervals,
                    colorscale: 'Viridis',
                    showscale: true
                },
                text: intervals.map(x => `${Math.round(x)}å¤©`),
                textposition: 'auto'
            };

            const layout = {
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: 'white' },
                xaxis: { 
                    gridcolor: 'rgba(255,255,255,0.2)',
                    tickangle: -45
                },
                yaxis: { 
                    gridcolor: 'rgba(255,255,255,0.2)',
                    title: 'é—´éš”å¤©æ•°'
                },
                margin: { t: 30, r: 30, b: 100, l: 50 }
            };

            Plotly.newPlot('interval-chart', [trace], layout, {responsive: true});
        }

        function createPredictionChart() {
            const traces = [];
            const colors = ['#FF6B6B', '#4ECDC4', '#FFD700', '#FF8E53', '#45B7D1', 
                           '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#A29BFE',
                           '#FD79A8', '#6C5CE7', '#74B9FF', '#00B894'];

            // æ·»åŠ å†å²æ•°æ®
            traces.push({
                x: historicalData.dates,
                y: Array(historicalData.dates.length).fill('å†å²å‘å¸ƒ'),
                mode: 'markers',
                type: 'scatter',
                marker: { size: 15, color: '#FFD700', symbol: 'diamond' },
                name: 'å†å²å‘å¸ƒ',
                text: historicalData.versions,
                hovertemplate: '%{text}<br>%{x}<extra></extra>'
            });

            // æ·»åŠ ä»Šå¤©çš„çº¿
            traces.push({
                x: ['2025-07-04', '2025-07-04'],
                y: ['å†å²å‘å¸ƒ', Object.keys(predictions)[Object.keys(predictions).length-1]],
                mode: 'lines',
                type: 'scatter',
                line: { color: '#FF6B6B', width: 3, dash: 'dash' },
                name: 'ä»Šå¤©',
                showlegend: false
            });

            // æ·»åŠ é¢„æµ‹ç»“æœ
            Object.entries(predictions).forEach(([method, dates], index) => {
                traces.push({
                    x: dates,
                    y: Array(dates.length).fill(method),
                    mode: 'markers',
                    type: 'scatter',
                    marker: { 
                        size: 12, 
                        color: colors[index % colors.length],
                        symbol: 'circle'
                    },
                    name: method,
                    text: dates.map((d, i) => `é¢„æµ‹ ${i+1}`),
                    hovertemplate: '%{text}<br>%{x}<extra></extra>'
                });
            });

            const layout = {
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: 'white' },
                xaxis: { 
                    gridcolor: 'rgba(255,255,255,0.2)',
                    range: ['2023-10-01', '2026-03-01']
                },
                yaxis: { 
                    gridcolor: 'rgba(255,255,255,0.2)'
                },
                margin: { t: 30, r: 30, b: 50, l: 150 },
                legend: { x: 1.02, y: 1 }
            };

            Plotly.newPlot('prediction-chart', traces, layout, {responsive: true});
        }

        function createPredictionsList() {
            const container = document.getElementById('predictions-list');
            container.innerHTML = '';

            Object.entries(predictions).forEach(([method, dates]) => {
                const row = document.createElement('div');
                row.className = 'method-row';
                
                const validDates = dates.filter(d => new Date(d) > today);
                
                row.innerHTML = `
                    <div class="method-name">${method}</div>
                    <div class="prediction-dates">
                        ${validDates.slice(0, 3).map((date, i) => {
                            const d = new Date(date);
                            const daysFromNow = Math.round((d - today) / (1000 * 60 * 60 * 24));
                            return `<div class="prediction-date">
                                ç¬¬${i+1}ä¸ª: ${d.toLocaleDateString('zh-CN')} 
                                <br><small>(${daysFromNow}å¤©å)</small>
                            </div>`;
                        }).join('')}
                    </div>
                `;
                
                container.appendChild(row);
            });
        }

        function createAnalysisSummary() {
            const container = document.getElementById('analysis-summary');
            
            // æ”¶é›†æ‰€æœ‰é¢„æµ‹çš„ç¬¬ä¸€ä¸ªæ—¥æœŸ
            const firstPredictions = [];
            Object.entries(predictions).forEach(([method, dates]) => {
                const validDates = dates.filter(d => new Date(d) > today);
                if (validDates.length > 0) {
                    firstPredictions.push({
                        date: new Date(validDates[0]),
                        method: method
                    });
                }
            });
            
            firstPredictions.sort((a, b) => a.date - b.date);
            
            const earliest = firstPredictions[0];
            const latest = firstPredictions[firstPredictions.length - 1];
            
            // è®¡ç®—3ä¸ªæœˆå†…çš„é¢„æµ‹æ•°é‡
            const threeMonthsLater = new Date(today);
            threeMonthsLater.setMonth(threeMonthsLater.getMonth() + 3);
            
            const nearTermPredictions = firstPredictions.filter(p => p.date <= threeMonthsLater);
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    <div style="background: rgba(255,215,0,0.2); padding: 15px; border-radius: 10px;">
                        <h4>âš¡ æœ€æ—©é¢„æµ‹</h4>
                        <p><strong>${earliest.date.toLocaleDateString('zh-CN')}</strong></p>
                        <p>æ–¹æ³•: ${earliest.method}</p>
                        <p>è·ä»Š: ${Math.round((earliest.date - today) / (1000 * 60 * 60 * 24))} å¤©</p>
                    </div>
                    
                    <div style="background: rgba(255,107,107,0.2); padding: 15px; border-radius: 10px;">
                        <h4>ğŸ”„ é¢„æµ‹èŒƒå›´</h4>
                        <p>æœ€æ—©: ${earliest.date.toLocaleDateString('zh-CN')}</p>
                        <p>æœ€æ™š: ${latest.date.toLocaleDateString('zh-CN')}</p>
                        <p>è·¨åº¦: ${Math.round((latest.date - earliest.date) / (1000 * 60 * 60 * 24))} å¤©</p>
                    </div>
                    
                    <div style="background: rgba(78,205,196,0.2); padding: 15px; border-radius: 10px;">
                        <h4>ğŸ“ è¿‘æœŸé›†ä¸­åº¦</h4>
                        <p>3ä¸ªæœˆå†…é¢„æµ‹: ${nearTermPredictions.length} ä¸ªæ–¹æ³•</p>
                        <p>å æ¯”: ${((nearTermPredictions.length / firstPredictions.length) * 100).toFixed(1)}%</p>
                        <p>ä¸€è‡´æ€§: ${nearTermPredictions.length >= 8 ? 'é«˜' : nearTermPredictions.length >= 5 ? 'ä¸­' : 'ä½'}</p>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 10px;">
                    <h4>ğŸ¯ é¢„æµ‹å»ºè®®</h4>
                    <p>åŸºäº ${Object.keys(predictions).length} ç§é¢„æµ‹æ–¹æ³•çš„ç»¼åˆåˆ†æï¼š</p>
                    <ul>
                        <li>ä¸‹ä¸€ä¸ªæ¨¡å‹æœ€å¯èƒ½åœ¨ <strong>${earliest.date.toLocaleDateString('zh-CN')}</strong> å·¦å³å‘å¸ƒ</li>
                        <li>å»ºè®®å…³æ³¨æ—¶é—´çª—å£ï¼š${earliest.date.toLocaleDateString('zh-CN')} - ${new Date(earliest.date.getTime() + 30*24*60*60*1000).toLocaleDateString('zh-CN')}</li>
                        <li>é¢„æµ‹ä¸€è‡´æ€§è¯„çº§ï¼š${nearTermPredictions.length >= 8 ? 'â­â­â­ é«˜ä¸€è‡´æ€§' : nearTermPredictions.length >= 5 ? 'â­â­ ä¸­ç­‰ä¸€è‡´æ€§' : 'â­ ä½ä¸€è‡´æ€§'}</li>
                    </ul>
                </div>
            `;
        }

        function updateStats() {
            // è®¡ç®—å¹³å‡é—´éš”
            const dates = historicalData.dates.map(d => new Date(d));
            let totalInterval = 0;
            for (let i = 1; i < dates.length; i++) {
                totalInterval += (dates[i] - dates[i-1]) / (1000 * 60 * 60 * 24);
            }
            const avgInterval = Math.round(totalInterval / (dates.length - 1));
            
            // æ‰¾åˆ°æœ€æ—©é¢„æµ‹
            const allFirstPredictions = [];
            Object.values(predictions).forEach(dates => {
                const validDates = dates.filter(d => new Date(d) > today);
                if (validDates.length > 0) {
                    allFirstPredictions.push(new Date(validDates[0]));
                }
            });
            
            allFirstPredictions.sort();
            const nextPrediction = allFirstPredictions[0];
            
            document.getElementById('avg-interval').textContent = avgInterval;
            document.getElementById('next-prediction').textContent = nextPrediction ? 
                nextPrediction.toLocaleDateString('zh-CN').slice(5) : '-';
        }

        function showTimelineFocus() {
            // é‡æ–°èšç„¦æ—¶é—´çº¿å›¾è¡¨
            const update = {
                'xaxis.range': ['2024-01-01', '2026-06-01']
            };
            Plotly.relayout('prediction-chart', update);
        }

        function showModelComparison() {
            // åˆ›å»ºæ¨¡å‹æ€§èƒ½å¯¹æ¯”å›¾è¡¨
            alert('åŠŸèƒ½å¼€å‘ä¸­ï¼šå°†æ˜¾ç¤ºå„æ¨¡å‹çš„RÂ²ã€MAEã€RMSEå¯¹æ¯”');
        }

        function showConfidenceAnalysis() {
            // æ˜¾ç¤ºç½®ä¿¡åº¦åˆ†æ
            alert('åŠŸèƒ½å¼€å‘ä¸­ï¼šå°†æ˜¾ç¤ºé¢„æµ‹ç½®ä¿¡åŒºé—´å’Œä¸ç¡®å®šæ€§åˆ†æ');
        }

        function generatePredictions() {
            // æ¨¡æ‹Ÿé‡æ–°ç”Ÿæˆé¢„æµ‹
            const button = event.target;
            button.textContent = 'é¢„æµ‹ä¸­...';
            button.disabled = true;
            
            setTimeout(() => {
                // æ·»åŠ ä¸€äº›éšæœºå˜åŒ–
                Object.keys(predictions).forEach(method => {
                    predictions[method] = predictions[method].map(date => {
                        const d = new Date(date);
                        const randomDays = (Math.random() - 0.5) * 10; // Â±5å¤©çš„éšæœºå˜åŒ–
                        d.setDate(d.getDate() + Math.round(randomDays));
                        return d.toISOString().split('T')[0];
                    });
                });
                
                // é‡æ–°åˆ›å»ºå›¾è¡¨
                createPredictionChart();
                createPredictionsList();
                createAnalysisSummary();
                updateStats();
                
                button.textContent = 'é‡æ–°é¢„æµ‹';
                button.disabled = false;
            }, 2000);
        }

        // åˆå§‹åŒ–
        window.addEventListener('load', initializeCharts);
    </script>
</body>
</html> 